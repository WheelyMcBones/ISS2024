[ProdConsSystem.html]
Facciamo il deployment del Progetto ProdCons.
La directory userDocs contiene gli html rappresentanti la descrizione **in itinere** del progetto:
prima di scrivere il codice dobbiamo appuntarci le modalità con cui procederemo.
Inseriamo l'ultima versione del codice all'interno del template.
Oggi vedremo la versione con Interaction; 

Autovalutazione: discutiamo quanto prodotto, e poi inseriamo la discussione e un'autovalutazione,
	sulla base di quanto il lavoro svolto corrisponde con la discussione.
	A --> F

Andiamo a scrivere i Test Plans: il codice dovrà soddisfare senz'altro i requisiti, e quindi anche
il testing.

Dopo l'Interconnessione, vedremo un ulteriore strato di software, realizzante il concetto di Actor
Settimana prossima vedremo i QakActors.

Naive: il codice contiene la progettazione con le socket, implementando la progettazione C/S
	con ServerSocket e Socket. Il Produttore deve conoscere (IP/porta) il Consumatore.

User Story: mettersi nei panni dell'utilizzatore del sistema.
Una request è osservabile, mentre una dispatch non e' osservabile: l'unico modo per sapere 
se è arrivata è mostrare il Consumatore.
Se un client invia una richiesta sincrona R1, e prima di ricevere una risposta ne invia una seconda R2
alla ricezione della risposta si aspetta la risposta A2 relativa a R2.

[Progetto: ProdCons0]
Implementazione con Interaction:
Si astrae dal protocollo e dall'implementazione specifica: per il Consumatore, sarà necessario
prevedere un Server che gestisce l'apertura di una connessione, e un gestore di messaggi.
Il gestore dei messaggi nel Consumatore è un componente attivo: alla ricezione di messaggi, il 
gestore dovrà inviare la risposta sulla stessa connessione (ossia, allo stesso Produttore).
Se non fosse attivo, dopo la ricezione di un messaggio, terminerebbe.
Il metodo elaborate(message, conn) ha come parametro la connessione, in quanto è necessaria 
per inviare le corrette risposte allo stesso Produttore. 

Il Produttore ottiene un supporto alla connessione mediante ConnectionFactory (in questo caso,
via TCP); viene poi creato un Thread che si occuperà di inviare e ricevere i messaggi.

La funzione receiveMsg() si aspetta una stringa, mentre receive() si aspetta un IApplMessage.


Alien: scriviamo un programma Python che invii messaggi al Consumer.
	Dovrà conoscere protocollo, ip/porta e formato dei messaggi.


