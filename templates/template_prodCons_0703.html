<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<head>
	<!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/css/foundation.min.css"
		crossorigin="anonymous">
	<script src="https://cdn.jsdelivr.net/npm/foundation-sites@6.7.4/dist/js/foundation.min.js"
		crossorigin="anonymous"></script>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" type="text/css" href="./commons/resources/styles/templateISS.css">
	<link rel="stylesheet" type="text/css" href="./commons/resources/styles/main.css">
	<link rel="stylesheet" type="text/css" href="./commons/resources/styles/navbar.css">
	<link rel="stylesheet" type="text/css" href="./commons/resources/styles/table.css">
	<link rel="stylesheet" type="text/css" href="./commons/resources/styles/code.css">
	<!-- <script type="text/javascript" src="./commons/resources/scripts/myScripts.js"></script> -->
	<style type="text/css">
		body {
			margin-left: 30px;
			margin-right: 30px;
		}

		;

		P {
			font-family: Tahoma;
			font-size: 10pt;
		}

		;

		a,
		a:visited,
		a:active,
		a:link,
		a:hover {
			text-decoration: underline;
			color: #545454;
			background-color: transparent;
			font-size: 93%;
		}

		a:hover {
			background-color: #cccccc;
		}


		hr {
			clear: both;
			height: 1px;
			color: #242424;
			background-color: transparent;
		}

		h1,
		h2,
		h3 {
			color: #242424;
			clear: left;
			font: 100% Tahoma, Helvetica, Arial, sans-serif;
			margin-bottom: 0.5em;
			padding-top: 0.5em;
			border-radius: 10px;
			padding: 5px;
		}

		top {
			width: 100%;
		}


		#i {
			color: #ff1010;
		}

		tt {
			font-family: "Arial";
			font-size: 90%;
			color: #006600;
		}

		em {
			font-family: "Arial";
			font-size: 80%;
			font-weight: bold;
			border-style: solid;
			border-color: #abe876;
			color: #1632cc;
		}

		bc {
			font-family: "Arial";
			font-size: 90%;
			font-weight: bold;
			color: #990000;
			background-color: #fcf8c7;
		}

		ks {
			font-family: "Arial";
			font-weight: bold;
			color: #0000CD;
			font-size: 90%;
		}

		kc {
			font-family: "Arial";
			font-weight: bold;
			color: #008000;
			font-size: 90%;
		}

		pre {
			font-family: "Consolas";
			font-size: 85%;
			background-color: #f5f5f5;
			border: 1.5px solid silver;
			padding: 5px;
		}

		m {
			font-family: "Helvetica";
			line-height: 100%;
			font-size: 75%;
		}

		div.body {

			font-size: 18px;
		}

		k {
			color: #990000;
			font-weight: bold;
			font-size: 90%;
		}

		h1 {
			font-size: 150%;
			background-color: #b2c0ff;
			padding: 10px;
		}

		h2 {
			background-color: #9ed8ff;
			font-size: 130%;
		}

		h3 {
			background-color: #e6ccff;
			font-size: 100%;
		}

		h4 {
			background-color: #ccffcc;
			font-size: 100%;
			width: 95%;
			border-radius: 5px;
			padding: 2px;
		}

		h5 {
			background-color: #d5ffb0;
			font-size: 100%;

		}

		div.req {
			background-color: #d9ffb3;
			font-size: 18px;
			width: 700px;
			border: 3px solid green;
			padding: 15px;
			margin: 10px;
		}

		div.remark {
			background-color: #E3F2FD;
			border: 1.5px solid #d5f2ed;
			padding: 15px;
			margin: 10px;
			border-radius: 25px;
		}

		table,
		th,
		td {
			border: 1px solid black;
			border-collapse: collapse;
		}

		ol,
		ul,
		li {
			margin: 0;
			margin-left: 10px;
			padding: 0;
			padding-bottom: 5px;
		}

		table,
		th,
		td {
			border: 1px solid black;
		}

		img {
			border: 1.5px solid #d5f2ed
		}

		a,
		a:visited,
		a:active,
		a:link,
		a:hover {
			text-decoration: underline;
			color: #545454;
			background-color: transparent;
		}

		div.wrapdesc {
			width: 90%;
			margin: auto;
		}

		div.imagedesc {
			width: 85%;
			margin: auto;
		}
	</style>



</head>






<title>Progetto: Produttori e Consumatore</title>
</head>

<!--
	<body onload="loadNav();">
		<div id="openButton" class="openButton" onclick="openNav(true)">&#9776; Menu</div>
		<div id="sidenav" class="sidenav">
			<a class="closeButton" href="javascript:void(0)" onclick="closeNav(true)">&times;</a>
			<a href=".README.html">ReadMe</a>
			<a class="sprint" href="../../../Sprint0/Codice/userDocs/Cold%20Storage%20Service%20-%20Natali%20V3.html">Sprint0</a>
			<a class="sprint" href="../../../Sprint1.0/Codice/userDocs/Sprint%201.0%20-%20V3.html">Sprint1.0</a>
			<a class="sprint" href="../../../Sprint1.1/Codice/userDocs/Sprint%201.1%20-%20V3.html">Sprint1.1</a>
			<a id="currentSprint" class="sprint" href="#">&#8211;&#8212; Sprint2 &#8212;&#8211;</a>
			<div class="sidenavSection">
				<a href="#Goal Sprint 2">Goal Sprint 2</a>
				<a href="#Requisiti">Requisiti</a>
				<a href="#Analisi dei Requisiti">Analisi dei Requisiti</a>
				<a href="#Analisi del Problema">Analisi del Problema</a>
				<a href="#Test Plan">Test Plan</a>
				<a href="#Progettazione">Progettazione</a>
				<a href="#Deployment">Deployment</a>
			</div>
			<p class="separator">&mdash;&mdash;&mdash;&ndash;&ndash;&mdash;&mdash;&mdash;</p>
			<a class="sprint" href="../../../Sprint3/Codice/userDoc/Sprint%203.html">Sprint3</a>
			<bottom-spacer/>
		</div>
-->

<body>
	<div id="top">
		<h1><b>LABORATORIO DI INGEGNERIA DEI SISTEMI SOFTWARE</b>
			<font size="5"></font>
		</h1>
	</div>

	<div class="body">
		<h2><b>Introduction</b></h2>

		<div class="remark">Un caso di studio con cui iniziare ad affrontare l’analisi e la progettazione di sistemi
			distribuiti è un sistema formato da a N Produttori che inviano informazione a 1 Consumatore.</div>

		<h2><b>Requirements</b></h2>

		<div class="remark"> Costruire un sistema software distribuito costituio da N (con N >= 1) Produttori che
			inviano
			informazione a 1 Consumatore, il quale deve elaborare tale informazione.<br>
			a dislocazione dei componenti sui nodi di elaborazione può essere:
			<ul>
				<li> OneNode: tutti i componenti operano nello stesso nodo; </li>
				<li> TwoNodes: gli N Produttori operano in uno stesso nodo, mentre il Consumatore opera in un diverso
					nodo;
				</li>
				<li> ManyNodes: il Consumatore opera in suo proprio nodo, mentre i Produttori operano su K nodi diversi
					(con K maggiore di 1, e al più uguale a N).
				</li>

			</ul>

		</div>


		<h2><b>Requirement analysis</b></h2>
		<div class="remark">
			<ul>
				<li>
					Produttore e Consumatore rappresentano gli unici due tipi di entità interagenti necessari
					all'interno del sistema.
				</li>
				<li>
					I requisiti non stabiliscono come l’informazione debba essere trasmessa e ricevuta.
				</li>
				<li>
					Le modalità di scambio di informazioni fra Produttori e Consumatore non sono stabilite:
					in particolare, non si precisa se il Produttore debba ricevere una risposta dal Consumatore.
				</li>
				<!-- <li>
					Il formato dei messaggi non è specificato: sarà necessario
				</li> -->
			</ul>
		</div>

	</div>

	<h2><b>Problem analysis</b></h2>
	<div class="remark">
		<h3><b>Architettura logica</b></h3>
		Stando all'analisi dei requisiti, l'architettura dovrà necessariamente prevedere una modalità di invio di
		messaggi dai Produttori al Consumatore.
		Sulla base di questo, l'architettura logica del sistema può essere organizzata in diversi modi, ad esempio:
		<ul>
			<li>
				<b>Modello Client-Server</b>: l'architettura prevede diversi client che effettuano richieste verso un
				server.
				In questo caso, i client sono rappresentati dai Produttori, mentre il server è dato dal Consumatore.
				Stando ai requisiti, l'interazione può essere asincrona non bloccante (le richieste dei client possono
				essere "fire & forget").
				In questo modello, i Produttori devono conoscere il Consumatore, mentre non è vero il viceversa.
			</li>
			<li>
				<b>Publisher-Subscriber (Pub/Sub)</b>: In questo caso, è presente un gestore della comunicazione
				(broker),
				a cui i publisher (i Produttori) e il subscriber (il Consumatore) sono iscritti; quest'ultimo riceverà i
				messaggi dal broker, che li avrà ricevuti precedentemente dai publisher. In questo modello, i Produttori
				e il Consumatore conoscono il broker.
			</li>
			<li>
				<b>Modello ad Eventi</b>: qui, i Produttori sono visti come puri emettitori di eventi; l'informazione
				viene emessa, e il Consumatore potrà ascoltarla. In questo modello, vi è totale disaccoppiamento delle
				parti.
			</li>
		</ul>
		In ogni caso, per comunicare, le due parti dovranno concordare un coerente formato dei messaggi. <br> <br>
		<h3><b>Ulteriori considerazioni</b></h3>
		Come già specificato, è necessario che si preveda una modalità di invio delle richieste dai Produttori al
		Consumatore, mentre non è necessario il viceversa.
		Qualora non si intenda sviluppare una modalità di risposta al Produttore (richiesta Fire & Forget), quest'ultimo non
		avrebbe modo di verificare la corretta ricezione della richiesta <i>dispatch</i>.
	</div>



	<h2><b>Test plans</b></h2>
	<div class="remark">
		I piani di test prevedono la verifica di una richiesta, proveniente da uno dei nodi Produttore per il nodo
		Consumatore, e sarà necessario verificare:
		<ul>
			<li>
				il corretto invio dei messaggi da parte dei Produttori.
			</li>
			<li>
				la corretta ricezione dei messaggi da parte del Consumatore.
			</li>
			<li>
				il corretto formato dei messaggi.
			</li>
		</ul>
		Qualora si intenda sviluppare una modalità di risposta al Produttore, diventa necessario prevedere le analoghe
		verifiche anche per tale messaggio.
	</div>
	<div class="remark">
		Le modalità di invio dei messaggi previste sono di due tipi: request e dispatch.
		<ul>
			<li>Una request prevede l'invio di una richiesta e l'attesa della ricezione di una corrispondente risposta
				da parte del Consumatore (sincrono). <br> Il testing per una request dovrà prevedere la verifica della
				correttezza della risposta attesa. </li>
			<li>Una dispatch prevede l'invio di un messaggio Fire&Forget: non prevede la ricezione di una risposta
				(asincrono).<br>Il testing per una dispatch dovrà prevedere l'utilizzo di un file di log, per
				verificarne la ricezione e le conseguenze attese.</li>
		</ul>
	</div>

	<h2><b>Project</b></h2>
	<div class="remark">
		La scelta di progettazione ricade sul modello Client-Server visto nella fase di Analisi, implementato sul
		protocollo TCP. Come specificato nella fase precedente, l'architettura prevede i Produttori come clienti e il
		Consumatore come server; inoltre, i client e il server non risiedono necessariamente sullo stesso nodo. Sulla
		base di queste informazioni:
		<ul>
			<li>
				I Produttori devono conoscere il Consumatore per potergli inviare una richiesta: ciascuno dei Produttori
				dovrà quindi conoscere indirizzo IP e porta su cui il Consumatore riceve le richieste.
			</li>
			<li>
				Si sceglie di prevedere due modalità di invio delle richieste: Request e Forward.
				<ul>
					<li>
						Per un messaggio Request, il Produttore resterà in attesa di una risposta (Sincrono) da parte
						del Consumatore: si prevede pertanto l'invio di un messaggio di ACK (acknowledgement) dal
						Consumatore per comunicare la ricezione della richiesta al Produttore.
					</li>
					<li>
						Per un messaggio Forward (Dispatch), il Produttore non si aspetta una risposta (Asincrono), e non è
						prevista quindi nessuna ulteriore gestione della comunicazione in tale scenario (Fire & Forget).
					</li>
				</ul>
			</li>
			<li>
				Il Consumatore gestirà le richieste in modo First In First Out (FIFO): sarà necessario prevedere una
				coda in cui inserire le richieste da gestire.
			</li>
			<li>
				Il formato dei messaggi scambiati sarà quello espresso e definito nella interfaccia IApplMessage.
			</li>
		</ul>
		Per abbattere il costo di progetto, la progettazione avviene sulla base delle librerie <i>
			unibo.basicomm23</i> già fornite. Attraverso di esse:
		<ul>
			<li>
				realizzeremo il Produttore come un client abilitato alla Trasmissione di messaggi: troviamo già
				implementata la logica per l'instaurazione della connessione con il Server, attraverso la classe
				<i>ActorNaiveCaller</i>; ci limiteremo quindi a scrivere la
				<i>business logic</i> della gestione dei messaggi.
			</li>
			<li>
				realizzeremo il Consumatore come un server abilitato alla Ricezione di messaggi: anche in questo caso,
				la
				logica per l'instaurazione della connessione bidirezionale è già implementata; la classe ServerFactory
				si occuperà di restituire un opportuno oggetto Server in grado di gestire la connessione. Ci limiteremo
				a implementare la gestione dei messaggi a livello applicativo, basandoci sull'interfaccia
				<i>IApplMsgHandler</i>.<br>
			</li>
		</ul>
	</div>

	</div>

	<h2>Testing</h2>


	<h2>Deployment</h2>


	<h2>Maintenance</h2>

	<!-- USEFUL
<table style="width:100%" border="1">
<tr>
<td style="width:50%">
</td>
<td></td>
</tr>
</table>
-->

	<br /><br />
	</div>

	<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white;display: flex;">
		By Tommaso Sgreccia - Email Istituzionale: tommaso.sgreccia@studio.unibo.it
		<img src="/home/wheelymcbones/Me/me.jpg" alt="mbot" width="15%" height="15%">
		GIT repo: https://github.com/WheelyMcBones/ISS2024
	</div>
</body>

</html>